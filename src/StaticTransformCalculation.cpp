#include <iostream>
#include <fstream>
#include <colmap/base/similarity_transform.h>
#include <colmap/optim/loransac.h>
#include <colmap/estimators/similarity_transform.h>
#include <colmap/util/math.h>
#include <vector>
#include <string>

using namespace colmap;

Eigen::Matrix4d getSimilarityTransform(std::vector<Eigen::Vector3d>& t1, std::vector<Eigen::Vector3d>& t2){

	colmap::SimilarityTransform3 estimate;
	estimate.Estimate(t1, t2);
	return estimate.Matrix(); 

}

int main(int argc, char** argv){

    // Read Keyframe file generated by orbslam3
    std::ifstream kfFile("/home/manshr/Keyframe.txt");
    std::vector<std::string> linesFromKFfile;
    std::vector<std::string> contentOfLine;
    std::vector<Eigen::Vector3d> KFPositionsInSlam;
    std::string lineInFile;
    std::cout << kfFile.is_open() << std::endl;
    if(kfFile.is_open()){

        while(std::getline(kfFile, lineInFile)){
            contentOfLine.clear();
            std::stringstream ss(lineInFile);
            while(ss.good()){
                std::string substr;
                std::getline(ss,substr,' ');
                contentOfLine.push_back(substr);

            }
            double X, Y, Z;
            X = std::stod(contentOfLine.at(1));
            Y = std::stod(contentOfLine.at(2));
            Z = std::stod(contentOfLine.at(3));
            KFPositionsInSlam.push_back(Eigen::Vector3d(X,Y,Z));
        }
        kfFile.close();

    }

    // Read KFPositionInENU file generated by GPSProcess node
    std::ifstream ENUFile("/home/manshr/KFPostionsInENU.txt");
    std::vector<std::string> linesFromENUfile;
    std::vector<Eigen::Vector3d> KFPositionsInENU;
    std::cout << ENUFile.is_open() << std::endl;
    if(ENUFile.is_open()){

        while(std::getline(ENUFile, lineInFile)){
            contentOfLine.clear();
            std::stringstream ss(lineInFile);
            while(ss.good()){
                std::string substr;
                std::getline(ss,substr,',');
                contentOfLine.push_back(substr);

            }
            double X, Y, Z;
            X = std::stod(contentOfLine.at(0));
            Y = std::stod(contentOfLine.at(1));
            Z = std::stod(contentOfLine.at(2));
            KFPositionsInENU.push_back(Eigen::Vector3d(X,Y,Z));
        }

        ENUFile.close();

    }
    
    
	
	std::ofstream converted_SLAM2ENU;
    converted_SLAM2ENU.open("/home/manshr/converted_SLAM2ENU.txt");
    //std::cout << KFPositionsInSlam.size() << std::endl;
	
	/*for(int i=0; i < KFPositionsInSlam.size(); i = i+11){
		std::vector<Eigen::Vector3d> windowVectorSLAM = std::vector<Eigen::Vector3d>(KFPositionsInSlam.begin() + i, KFPositionsInSlam.begin() + i + 11);
		std::vector<Eigen::Vector3d> windowVectorENU = std::vector<Eigen::Vector3d>(KFPositionsInENU.begin() + i, KFPositionsInENU.begin() + i + 11);
		Eigen::Matrix4d T_SLAM2ENU = getSimilarityTransform(windowVectorSLAM, windowVectorENU);
    //std::cout << T_SLAM2ENU <<std::endl;
		Eigen::Vector4d point(windowVectorSLAM.at(5)[0],windowVectorSLAM.at(5)[1],windowVectorSLAM.at(5)[2],1);
        Eigen::Vector4d pointInENU = T_SLAM2ENU * point;
		converted_SLAM2ENU << pointInENU[0]<< "," << pointInENU[1]<< "," << pointInENU[2] << std::endl;
   std::cout << i << std::endl;

	}*/
    std::cout << "File Reading complete!" << std::endl;

	
    //Eigen::Matrix4d T_SLAM2ENU = getSimilarityTransform(KFPositionsInSlam, KFPositionsInENU);

    //std::cout << T_SLAM2ENU <<std::endl;
    colmap::RANSACOptions ransac_options;
    ransac_options.max_error = 0.1;
    ransac_options.min_inlier_ratio = 0.2;
    ransac_options.confidence = 0.99;
    ransac_options.dyn_num_trials_multiplier = 3.0;

/*
      // Complete set, Robust alignment	
      LORANSAC<SimilarityTransformEstimator<3>, SimilarityTransformEstimator<3>>
      ransac(ransac_options);
    const auto report = ransac.Estimate(KFPositionsInSlam, KFPositionsInENU);
    SimilarityTransform3 model = SimilarityTransform3(report.model);
    Eigen::Matrix4d T_SLAM2ENU = model.Matrix();
    std::cout << T_SLAM2ENU <<std::endl;

    std::vector<Eigen::Vector3d> convertedKFList;  
    for(auto& ele : KFPositionsInSlam){
        Eigen::Vector4d point(ele[0],ele[1],ele[2],1);
        Eigen::Vector4d pointInENU = T_SLAM2ENU * point;
        //std::cout << pointInENU << std::endl;
        convertedKFList.push_back(Eigen::Vector3d(pointInENU[0],pointInENU[1],pointInENU[2]));
        converted_SLAM2ENU << pointInENU[0]<< "," << pointInENU[1]<< "," << pointInENU[2] << std::endl;
    }

*/
    // Windowed, Robust alignment
    int n = 3; // window size
    int mid = n/2;
    std::cout << mid << std::endl;
    std::vector<Eigen::Vector3d> convertedKFList;
    std::vector<Eigen::Vector3d> midKFList; // used for calculating alignment error.
    for(int i=0; i < KFPositionsInSlam.size(); i = i+1){
		std::vector<Eigen::Vector3d> windowVectorSLAM = std::vector<Eigen::Vector3d>(KFPositionsInSlam.begin() + i, KFPositionsInSlam.begin() + i + n);
		std::vector<Eigen::Vector3d> windowVectorENU = std::vector<Eigen::Vector3d>(KFPositionsInENU.begin() + i, KFPositionsInENU.begin() + i + n);
                LORANSAC<SimilarityTransformEstimator<3>, SimilarityTransformEstimator<3>>
      		ransac(ransac_options);
    		const auto report = ransac.Estimate(windowVectorSLAM, windowVectorENU);
    		SimilarityTransform3 model = SimilarityTransform3(report.model);
    		Eigen::Matrix4d T_SLAM2ENU = model.Matrix();
            std::cout << T_SLAM2ENU << "\n -----------------" << std::endl;
		Eigen::Vector4d point(windowVectorSLAM.at(mid)[0],windowVectorSLAM.at(mid)[1],windowVectorSLAM.at(mid)[2],1);
        	Eigen::Vector4d pointInENU = T_SLAM2ENU * point;
                convertedKFList.push_back(Eigen::Vector3d(pointInENU[0],pointInENU[1],pointInENU[2]));
		midKFList.push_back(Eigen::Vector3d(windowVectorENU.at(mid)[0],windowVectorENU.at(mid)[1],windowVectorENU.at(mid)[2]));
		converted_SLAM2ENU << pointInENU[0]<< "," << pointInENU[1]<< "," << pointInENU[2] << std::endl;

	}

   
    /*const int min_common_images = 3;
    if (report.support.num_inliers < static_cast<size_t>(min_common_images)) {
        std::cout << false << std::endl;
    }
	else{
        std::cout << true << std::endl;
    }*/
    converted_SLAM2ENU.close();

    // Error calculation
    std::vector<double> errors;
    for(int i = 0; i < convertedKFList.size(); i++){
        errors.push_back((convertedKFList[i] - midKFList[i]).norm());
    }

    std::cout << StringPrintf(" => Alignment error: %f (mean), %f (median)",
                              Mean(errors), Median(errors))
              << std::endl;
    
    

    return 0;
}
